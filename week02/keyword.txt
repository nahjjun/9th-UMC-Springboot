- **SOLID**

    SOLID 원칙이란, 객체지향 설계에서 지켜줘야 할 5개의 소프트웨어 개발 원칙을 말한다.

    1. **SRP(Single Responsibility Principle)** : 단일 책임 원칙
        - **클래스(객체)는 단 하나의 책임(기능)만 가져야 한다는 원칙**
        - 해당 원칙을 따름으로써 한 책임의 변경으로부터 다른 책임의 변경으로의 연쇄작용을 극복할 수 있게 된다.
    2. **OCP(Open Closed Principle)** : 개방 폐쇄 원칙
        - **확장에 열려있어야 하며, 수정에는 닫혀있어야 한다**
        - 기능 추가 요청이 오면 클래스 확장을 통해 손쉽게 구현하면서 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성해야 하는 설계 기법

            → 즉, **추상화 사용(Interface)을 통한 관계 추축을 권장하는 의미**

    3. **LSP(Listov Substitution Principle)** : 리스코프 치환 원칙
        - **서브 타입은 언제나 부모 타입으로 교체할 수 있어야 한다**
        - 다형성의 원리를 이용하기 위한 원칙 개념
        - 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면, 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 하는 것
    4. **ISP(Interface Segregation Principle)** : 인터페이스 분리 원칙
        - **인터페이스를 각각 사용에 맞게 끔 잘게 분리해야한다는 설계 원칙**
        - 인터페이스의 단일 책임 강조
    5. **DIP(Dependency Inversion Principle)** : 의존 역전 원칙
        - **어떤 클래스를 참조해서 사용해야하는 상황이 생긴다면, 해당 class를 직접 참조하지 않고 그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙**
        - 즉, 인터페이스에 의존하라는 뜻

    SOLID 객체 지향 원칙을 적용하면 **코드를 확장하고 유지 보수 관리하기가 더 쉬워지며**, 불필요한 복잡성을 제거해 **리팩토링에 소요되는 시간을 줄임으로써 개발의 생산성을 높일 수 있음**

    (객체 지향을 배울 때 익혔던 **추상화, 상속, 인터페이스, 다형성** 등의 개념들을 재정립한 것임)

- **DI**

    메인 모듈이 직접 다른 하위 모듈에 대한 의존성을 주기보다, 중간에 의존성 주입자가 해당 부분을 가로채 메인 모듈이 간접적으로 의존성을 주입하는 방식

- **IoC**

    사용할 객체를 **직접 생성하지 않고**, 객체의 생명주기 관리를 **외부**(스프링 컨테이너)**에 위임**하는 것

- **생성자 주입 vs 수정자, 필드 주입 차이**

    생성자 주입은 의존성이 변경 불가능하고, 의존성이 없으면 객체 자체가 생성이 불가능하므로 안전성이 높지만, 수정자, 필드 주입은 불변성을 보장하기 어렵고, 필드 주입같은 경우는 Spring 컨테이너에 의존하게 된다.

- **AOP**

    관점 지향 프로그래밍. 관심사를 기준으로 프로그램을 나누는 방법

    - 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화 하겠다는 것

        → 모듈화 : 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것


    ![image.png](attachment:e27542af-1baa-4172-bcb7-71303394fb1a:image.png)

    AOP 관점을 기준으로 로직을 모듈화한다는 것 : 코드들을 부분적으로 나누어서 모듈화하겠다는 의미

    이때, 소스코드 상에서 다른 부분에 계속 반복해서 쓰는 코드들을 발견할 수 있는데, 이를 **“흩어진 관심사”**라고 함

    - AOP 주요 개념


        | **Aspect** | 위에서 설명한 **흩어진 관심사를 모듈화 한 것**.
        주로 부가기능을 모듈화함 |
        | --- | --- |
        | **Target** | **Aspect를 적용하는 곳**(클래스, 메서드 등) |
        | **Advice** | - 실질적으로 어떤 일을 해야할 지에 대한 것.
        - **실질적인 부가기능을 담은 구현체** |
        | **JointPoint** | - **Advice가 적용될 위치, 끼어들 수 있는 지점**.
        - 메서드 진입 지점, 생성자 호출 지점, 필드에서 값을 꺼내올 때 등 다양한 시점에 적용 가능 |
        | **PointCut** | - **JointPoint의 상세한 스펙을 정의한 것.**
        - “A란 메서드의 진입 시점에 호출할 것”과 같이 **더욱 구체적으로 Advice가 실행될 지점을 정할 수 잇음** |
    - 스프링 AOP 특징
        - 프록시 패턴 기반의 AOP 구현체

            → 프록시 객체를 쓰는 이유 = 접근 제어 및 부가 기능을 추가하기 위해서

        - 스프링 빈에만 AOP 적용 가능함
        - 모든 AOP 기능을 제공하는 것이 아닌, 스프링 IoC와 연동하여 엔터프라이즈 애플리케이션에서 가장 흔한 문제(중복 코드, 프록시 클래스 작성의 번거로움, 객체 간 관계 복잡도 증가 등)에 대한 해결책을 지원하는 것이 목적임

        [프록시 패턴이란?](https://www.notion.so/271b57f4596b80f5af5fc8097eb7396f?pvs=21)


    [[Spring] 스프링 AOP (Spring AOP) 총정리 : 개념, 프록시 기반 AOP, @AOP](https://engkimbs.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81AOP)

    ㄴ> 자세한 사용법은 해당 사이트 참고

- **서블릿**

    자바 기반의 웹 어플리케이션에서 클라이언트의 요청을 받아 처리하고, 응답을 생성해 돌려주는 서버 측 프로그램